// Code generated by otelifacegen; DO NOT EDIT.
// github.com/ernado/example/internal/otelifacegen

package o11y

import (
	"context"
	"fmt"
	"github.com/ernado/example"
	"github.com/ernado/example/internal/semconv"
	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	otelsemconv "go.opentelemetry.io/otel/semconv/v1.34.0"
	"go.opentelemetry.io/otel/trace"
	"time"
)

// Ensure that ServiceInstrumentation implements example.Service.
var _ example.Service = (*ServiceInstrumentation)(nil)

// ServiceInstrumentation wraps example.Service with OpenTelemetry instrumentation.
type ServiceInstrumentation struct {
	impl          example.Service
	tracer        trace.Tracer
	meter         metric.Meter
	methodCounter metric.Int64Counter
	methodTime    metric.Float64Histogram
}

// NewServiceInstrumentation creates a new instrumented wrapper.
func NewServiceInstrumentation(
	impl example.Service,
	tracerProvider trace.TracerProvider,
	meterProvider metric.MeterProvider,
) (*ServiceInstrumentation, error) {
	meter := meterProvider.Meter("github.com/ernado/example")
	tracer := tracerProvider.Tracer("github.com/ernado/example")

	methodCounter, err := meter.Int64Counter("operation.count")
	if err != nil {
		return nil, errors.Wrap(err, "create method counter")
	}

	methodTime, err := meter.Float64Histogram("operation.time")
	if err != nil {
		return nil, errors.Wrap(err, "create method time histogram")
	}

	return &ServiceInstrumentation{
		impl:   impl,
		tracer: tracer,
		meter:  meter,

		methodCounter: methodCounter,
		methodTime:    methodTime,
	}, nil
}

// instrument operation call.
func (i *ServiceInstrumentation) instrument(ctx context.Context, operation string, err *error) context.CancelFunc {
	ctx, span := i.tracer.Start(
		ctx,
		fmt.Sprintf("Service.%s", operation), // TODO: Do we really need "Service." prefix?
		trace.WithAttributes(
			semconv.Operation(operation),
			semconv.System("Service"),
		),
	)
	start := time.Now()
	return func() {
		attributes := []attribute.KeyValue{
			semconv.Operation(operation),
			semconv.System("Service"),
		}
		if err != nil && *err != nil {
			e := *err
			span.AddEvent("error", trace.WithAttributes(
				otelsemconv.ErrorMessage(e.Error()),
				attribute.String("error.detailed", fmt.Sprintf("%+v", e)),
			))
			span.SetStatus(codes.Error, "Operation failed")
			if errors.Is(e, context.Canceled) {
				attributes = append(attributes, semconv.ResultCanceled())
			} else {
				attributes = append(attributes, semconv.ResultError())
			}
		} else {
			span.SetStatus(codes.Ok, "Operation succeeded")
			attributes = append(attributes, semconv.ResultOk())
		}
		span.End()
		i.methodCounter.Add(ctx, 1, metric.WithAttributes(attributes...))
		i.methodTime.Record(ctx, time.Since(start).Seconds(), metric.WithAttributes(
			semconv.Operation(operation),
			semconv.System("Service"),
		))
	}
}

// CreateTask adds instrumentation and delegates to the underlying implementation.
func (i *ServiceInstrumentation) CreateTask(ctx context.Context, title string) (ret1 *example.Task, err error) {
	defer i.instrument(ctx, "CreateTask", &err)()
	return i.impl.CreateTask(ctx, title)
}

// DeleteTask adds instrumentation and delegates to the underlying implementation.
func (i *ServiceInstrumentation) DeleteTask(ctx context.Context, id int64) (err error) {
	defer i.instrument(ctx, "DeleteTask", &err)()
	return i.impl.DeleteTask(ctx, id)
}

// GenerateError adds instrumentation and delegates to the underlying implementation.
func (i *ServiceInstrumentation) GenerateError(ctx context.Context) (err error) {
	defer i.instrument(ctx, "GenerateError", &err)()
	return i.impl.GenerateError(ctx)
}

// ListTasks adds instrumentation and delegates to the underlying implementation.
func (i *ServiceInstrumentation) ListTasks(ctx context.Context) (ret1 []*example.Task, err error) {
	defer i.instrument(ctx, "ListTasks", &err)()
	return i.impl.ListTasks(ctx)
}
