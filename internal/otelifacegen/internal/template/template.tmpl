{{- /*gotype: github.com/ernado/example/internal/otelifacegen/internal/template.Data*/ -}}

// Code generated by otelifacegen; DO NOT EDIT.
// github.com/ernado/example/internal/otelifacegen

package {{.PkgName}}

import (
{{- range .Imports}}
	{{. | ImportStatement}}
{{- end}}
)

{{range $i, $mock := .Mocks -}}

{{- if not $.SkipEnsure -}}
// Ensure that {{.Name}} implements {{$.SrcPkgQualifier}}{{.InterfaceName}}.
var _ {{$.SrcPkgQualifier}}{{.InterfaceName -}}
	{{- if .TypeParams }}[
		{{- range $index, $param := .TypeParams}}
			{{- if $index}}, {{end -}}
			{{if $param.Constraint}}{{$param.Constraint.String}}{{else}}{{$param.TypeString}}{{end}}
		{{- end -}}
		]
	{{- end }} = (*{{.Name}})(nil)
{{- end}}

// {{.Name}} wraps {{$.SrcPkgQualifier}}{{.InterfaceName}} with OpenTelemetry instrumentation.
type {{.Name}}
{{- if .TypeParams -}}
	[{{- range $index, $param := .TypeParams}}
			{{- if $index}}, {{end}}{{$param.Name | Exported}} {{$param.TypeString}}
	{{- end -}}]
{{- end }} struct {
	impl {{$.SrcPkgQualifier}}{{.InterfaceName}}
	{{- if .TypeParams -}}
		[{{- range $index, $param := .TypeParams}}
			{{- if $index}}, {{end -}}
			{{if $param.Constraint}}{{$param.Constraint.String}}{{else}}{{$param.TypeString}}{{end}}
		{{- end -}}]
	{{- end}}
	tracer trace.Tracer
	meter  metric.Meter
	methodCounter metric.Int64Counter
	methodTime    metric.Float64Histogram
}

// New{{.Name}} creates a new instrumented wrapper.
func New{{.Name}}(
	impl {{$.SrcPkgQualifier}}{{.InterfaceName}}
	{{- if .TypeParams -}}
		[{{- range $index, $param := .TypeParams}}
			{{- if $index}}, {{end -}}
			{{if $param.Constraint}}{{$param.Constraint.String}}{{else}}{{$param.TypeString}}{{end}}
		{{- end -}}]
	{{- end}},
	tracerProvider trace.TracerProvider,
	meterProvider metric.MeterProvider,
) (*{{.Name}}, error)
{{- if .TypeParams -}}
	[{{- range $index, $param := .TypeParams}}
		{{- if $index}}, {{end}}{{$param.Name | Exported}}
	{{- end -}}]
{{- end }} {
	meter := meterProvider.Meter("github.com/ernado/example")
    tracer := tracerProvider.Tracer("github.com/ernado/example")

	methodCounter, err := meter.Int64Counter("operation.count")
	if err != nil {
		return nil, errors.Wrap(err, "create method counter")
	}

	methodTime, err := meter.Float64Histogram("operation.time")
	if err != nil {
		return nil, errors.Wrap(err, "create method time histogram")
	}

	return &{{.Name}}
	{{- if .TypeParams -}}
		[{{- range $index, $param := .TypeParams}}
			{{- if $index}}, {{end}}{{$param.Name | Exported}}
		{{- end -}}]
	{{- end }}{
		impl:   impl,
		tracer: tracer,
		meter:  meter,

		methodCounter: methodCounter,
		methodTime:    methodTime,
	}, nil
}

// instrument operation call.
func (i *{{$mock.Name}}) instrument(ctx context.Context, operation string, err *error) context.CancelFunc {
	ctx, span := i.tracer.Start(
		ctx,
		fmt.Sprintf("{{.InterfaceName}}.%s", operation), // TODO: Do we really need "{{.InterfaceName}}." prefix?
		trace.WithAttributes(
			semconv.Operation(operation),
			semconv.System("{{.InterfaceName}}"),
		),
	)
	start := time.Now()
	return func() {
		attributes := []attribute.KeyValue{
			semconv.Operation(operation),
			semconv.System("{{.InterfaceName}}"),
		}
		if err != nil && *err != nil {
			e := *err
			span.AddEvent("error", trace.WithAttributes(
				otelsemconv.ErrorMessage(e.Error()),
				attribute.String("error.detailed", fmt.Sprintf("%+v", e)),
			))
			span.SetStatus(codes.Error, "Operation failed")
			if errors.Is(e, context.Canceled) {
				attributes = append(attributes, semconv.ResultCanceled())
			} else {
				attributes = append(attributes, semconv.ResultError())
			}
		} else {
			span.SetStatus(codes.Ok, "Operation succeeded")
			attributes = append(attributes, semconv.ResultOk())
		}
		span.End()
		i.methodCounter.Add(ctx, 1, metric.WithAttributes(attributes...))
		i.methodTime.Record(ctx, time.Since(start).Seconds(), metric.WithAttributes(
			semconv.Operation(operation),
            semconv.System("{{.InterfaceName}}"),
		))
	}
}

{{range .Methods}}
// {{.Name}} adds instrumentation and delegates to the underlying implementation.
func (i *{{$mock.Name}}
{{- if $mock.TypeParams -}}
	[{{- range $index, $param := $mock.TypeParams}}
		{{- if $index}}, {{end}}{{$param.Name | Exported}}
	{{- end -}}]
{{- end -}}
) {{.Name}}({{.ArgList}}) {{.ReturnArgTypeList}} {
	{{- if not .ReturnsError}}
	var err error
	{{- end}}
	defer i.instrument(ctx, "{{.Name}}", &err)()
	{{- if .Returns}}
	return i.impl.{{.Name}}({{.ArgCallList}})
	{{- else}}
	i.impl.{{.Name}}({{.ArgCallList}})
	{{- end}}
}
{{end}}
{{end -}}
